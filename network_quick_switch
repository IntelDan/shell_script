#!/bin/sh
# author:tracyone,tracyone@live.cn
# description:这个小脚本的功能快速切换mac地址和ip地址.
	# 1,用户可以迅速的切换到任意配置好的ip配置上
	# 2,用户可以迅速恢复到最初的ip配置上
	# 3,用户可以在配置界面上添加/删除一个新的配置，也可以直接修改配置文件
	# 配置文件的格式:新一行以#开头的为注释，所有注释会被忽略,所有空行会被忽略
	# 配置名:IP地址:MAC地址:DNS
# history:2014-01-17/22:37:25 windows xp测试成功

# {{{环境变量接口
ORIG_IFUPDOWN_CFG="/etc/network/interfaces.org" #此文件是ifdownup命令的配置文件的备份文件为了统一windows下同样使用这个文件..
IFUPDOWN_CFG="/etc/network/interfaces" #此文件是ifdownup命令的配置文件为了统一windows下同样使用这个文件..
USER_NETOWRK_CFG="quick_sw.txt" #本脚本网络配置文件 
# 下面4个环境变量作为用户输入保存的地方..
CFG_NAME=""
CFG_IP=""
CFG_MAC=""
CFG_DNS=""
#下面4个变量是上面4个变量对应的配置行里面的位置..
CFG_NAME_IDX=1
CFG_IP_IDX=2
CFG_MAC_IDX=3
CFG_DNS_IDX=4
TEMP_FILE="./temp_file"
# }}}

# {{{函数接口

#获取字符串长度..
#接受一个参数,就是字符串..
function get_str_len()
{
	echo ${#1}
}

#检测操作系统类型..
#返回Unix或者Nt+版本，例如Nt5.1
function get_os_type()
{
	local os_type=$(uname)
	local nt_ver=""
	if [[ "${os_type}" == "Linux" || "${os_type}" == "Darwin" ]]; then
		echo "Unix"
	else
		nt_ver=$(reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" //v CurrentVersion | awk '{print $3 "\t"}'  | sed -n '5p')
		echo "Nt${nt_ver}"
	fi
}

function clear_screen()
{
	# clear screen
	echo -e "\e[2J\e[1;1H"
}
# 返回当前网络链接的mac地址的字符串...
# 结果的形式是:08:00:00:00:00:01
function get_mac_address()
{
	local mac_address=""
	if [[ $(get_os_type) == "Unix" ]]; then
		mac_address=$(ifconfig | grep $(get_netcard_name) | tr -s ' ' | cut -d ' ' -f5)
		#mac_address=${mac_address//:/} #去掉冒号.. 
	else
		mac_address=$(getmac | sed -n '4p' | cut -d ' ' -f1) 
		mac_address=${mac_address//-/:} #加入冒号
	fi
	echo "${mac_address}"
}

#获取当前网络链接的ip地址
#如果为dhcp则返回空...
function get_ip_addr()
{
	is_dhcp
	if [[ $? -ne 0 ]]; then
		local ip_address=""
		if [[ $(get_os_type) == "Unix" ]]; then
			ip_address=$(ifconfig $(get_netcard_name) | grep 'inet ' | tr -s ' ' | cut -d ' ' -f3)
			ip_address=${ip_address#*:}
		else
			ip_address=$(netsh interface ip show address | grep -v '^$' | sed -n '3p' | awk '{print $3}' )
		fi
		echo "${ip_address}"
	else
		echo ""
	fi
}

#获取当前网络链接的掩码
#如果为dhcp则返回空...
function get_netmask()
{
	is_dhcp
	if [[ $? -ne 0 ]]; then
		local ip_address=""
		if [[ $(get_os_type) == "Unix" ]]; then
			ip_address=$(ifconfig $(get_netcard_name) | grep 'inet ' | tr -s ' ' | cut -d ' ' -f5)
			ip_address=${ip_address#*:}
		else
			ip_address=$(netsh interface ip show address | grep -v '^$' | sed -n '4p' | awk '{print $2}' )
		fi
		echo "${ip_address}"
	else
		echo ""
	fi
}

#获取当前网络链接的网关
#如果为dhcp则返回空...
function get_gw()
{
	is_dhcp
	if [[ $? -ne 0 ]]; then
		local ip_address=""
		if [[ $(get_os_type) == "Unix" ]]; then
			ip_address=$(route -n | grep UG | awk '{print $2 "\t"}') #U表示启动，G表示这是gateway 
			ip_address=${ip_address#*:}
		else
			ip_address=$(netsh interface ip show address | grep -v '^$' | sed -n '5p' | awk '{print $2}' )
		fi
		echo "${ip_address}"
	else
		echo ""
	fi
}

# 下面函数用于添加网络配置文件到${CUR_NETWORK_CFG}中..
function add_cfg()
{
	clear_screen
	echo -e "== Add network cfg guide =="
	if [[ ! -s ${USER_NETOWRK_CFG} ]]; then
		echo "# 配置格式为:" > ${USER_NETOWRK_CFG}
		echo "# 配置名;IP地址;MAC地址;DNS" >> ${USER_NETOWRK_CFG}
		echo "# "#"开头的会被忽略，可作为注释，但是只能放在单独一行" >> ${USER_NETOWRK_CFG}
		echo "# 后面的IP地址和MAC地址和DNS都可以为空，如果为空那么对应项将保持原来设置" >> ${USER_NETOWRK_CFG}
		echo "# 配置名不能空" >> ${USER_NETOWRK_CFG}
	fi

	while [[ 1 ]]; do
		read -p "Enter the name of config:" temp_name
		read -p "Enter ip address(.ie 192.168.1.11):" temp_ip
		read -p "Enter mac address(.ie 2b:2b:52:01:31:41):" temp_mac
		read -p "Enter dns address(.ie 202.100.128.68):" temp_dns
		echo "${temp_name};${temp_ip};${temp_mac};${temp_dns}" >> ${USER_NETOWRK_CFG}
		read -n1 -p "Would you like you to add one more config?[y/n]" user_input
		echo -e "\n"
		if [[ "${user_input}" == "" || "${user_input}" == [yY] ]]; then
			continue
		else
			break
		fi
	done
}

# windows only
# 返回当前网卡在注册表的相对位置，具体来说就是HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}下一级的数字
function get_pos_of_mac_in_reg()
{
	local interface_guid=$(getmac | sed -n '4p' | cut -d '_' -f2)
	local temp_guid=""
	local -i TEMP_NUM=0
	local temp_num_str=$(printf "%04d" $TEMP_NUM) 
	while [[ 1 ]]
	do
		temp_guid=$(reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}\\${temp_num_str}" | grep NetCfgInstanceId | awk '{print $3 "\t"}' )
		if [ $temp_guid = $interface_guid ]; then
			break
		fi
		let "TEMP_NUM+=1"
		if [[ ${TEMP_NUM} -gt 60 ]]; then
			echo "Can't not found any valid interface guid"
			return 3
		fi
		temp_num_str=$(printf "%04d" $TEMP_NUM) 
	done
	echo ${temp_num_str}
}

# 通过修改注册表来修改我们的网卡mac地址....具体来说就是:
# HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}下对应的文件夹
# 其中键:Networkaddress表示的网卡地址，其中Netcfginstanceid:表示每个网卡唯一的GUID
# 这个函数接受一个参数代表mac地址以16进制的形式来表示，例如345612780017
# 成功返回0，否则非0,1代表传入字符长度不符合，2代表有非法字符，3代表找不到网卡..
function set_mac_addr()
{
	echo "Setting mac address $1 ..."
	if [[ $(get_os_type) == "Unix" ]]; then
		if [[ "$(cat ${IFUPDOWN_CFG} | grep "^ *auto .*$(get_netcard_name)" )" == "" ]]; then
			sudo echo -e "auto $(get_netcard_name)\niface $(get_netcard_name) inet static" >> ${IFUPDOWN_CFG}
			sudo echo -e "hwaddress $1" >> ${IFUPDOWN_CFG}
		else
			# 配置中出现该网卡的配置，那么我们将强制改为静态
			# 插入iface语句并设置了静态
			sudo sed -ie "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/^ *iface.*/iface $(get_netcard_name) inet static/}" ${IFUPDOWN_CFG}
			# 判断是否存在hwaddress关键字，不存在的话在在第二个auto的前一行插入address及其ip地址..和默认netmask
			if [[ "$(sed -n "/^ *auto .*$(get_netcard_name)/,/^ *auto/{/^ *address.*/p}" ${IFUPDOWN_CFG})" == "" ]]; then
				sed -e "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/\(^ *iface.*\)/\1\nhwaddress $1/g}" ${IFUPDOWN_CFG}
			else
				sudo sed -ie "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/^ *hwaddress.*/hwaddress $1/}" ${IFUPDOWN_CFG}
			fi
		fi
	else
		echo "Searching interface guid.."
		temp_num_str=$(cat ${ORIG_IFUPDOWN_CFG} | grep reg_pos_of_mac | cut -d ';' -f2)
		if [[ ${temp_num_str} == "" || ! -s ${ORIG_IFUPDOWN_CFG} ]]; then
			temp_num_str=$(get_pos_of_mac_in_reg)
		fi
		#mac_address=${mac_address//:/} #去掉冒号.. 
		reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\\{4D36E972-E325-11CE-BFC1-08002bE10318\}\\$temp_num_str //v  NetworkAddress //d ${1//:/} //f
	fi
	return 0
}

# 此函数的作用是读取固定格式的文本里面的一个field
# 接受3个参数，$1为文本的所在路径和名字,$2是读取第几行,$3是读取这一行的第几个域
# 返回一个参数用于返回该字段的内容
function read_a_field_of_conf()
{
	local conf_field=""
	conf_field=$(grep -v '^ *#' $1 | grep -v '^$' | sed -n "${2}p" | cut -d ';' -f $3) 
	echo "${conf_field}"
}

#下面的函数读取配置文件中的指定行的对象名字
# 接受2个参数，$1为文本的所在路径和名字,$2是读取第几行
# 返回一个参数用于返回该行的名字...
function read_a_name_of_conf()
{
	local cfg_name=""
	cfg_name=$(read_a_field_of_conf $1 $2 1) #第一个域固定为该行配置的名字，这是人为规定的. 
	echo "${cfg_name}"
}

# return the name of netcard name
function get_netcard_name()
{
	if [[ $(get_os_type) == "Unix" ]]; then
		local net_card_str=$(route -n | sed -n '3p' | awk '{print $8 "\t"}' )
	else
		local net_card_str=$(netsh interface ip show address | sed -n '2p' | cut -d '"' -f 2)
	fi
	echo "${net_card_str}"
}

# 判断当前是否为dhcp
# 如果是返回0,否则非0..
function is_dhcp()
{
	local temp=""
	if [[ $(get_os_type) == "Unix" ]]; then
		temp=$(ps ax | grep dhclient | grep -v grep | grep $(get_netcard_name))	
	else
		temp=$(netsh -c interface dump | grep 'dhcp' | grep $(get_netcard_name))
	fi
	if [[ "${temp}" == "" ]]; then
		return 1
	else
		return 0
	fi
}

function get_netcard_id()
{
	local temp_num_str=""
	local netcatd_id=""
	temp_num_str=$(get_pos_of_mac_in_reg)
	netcatd_id=$(reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}\\${temp_num_str}" | grep ComponentId | cut -d '&' -f2 )
	echo ${netcatd_id}
}

# 重启网卡..
function reset_netcard()
{
	local os_type=$(get_os_type)
	local netcatd_id=""
	echo "Restarting network card $(get_netcard_name)..."
	if [[ "${os_type}" == "Unix" ]]; then
		sudo ifdown --force $(get_netcard_name) 
		sleep 2
		sudo ifup --force $(get_netcard_name)
	else
		netcatd_id=$(cat ${ORIG_IFUPDOWN_CFG} | grep netcatd_id | cut -d ';' -f2)
		if [[ ${netcatd_id} == "" || ! -s ${ORIG_IFUPDOWN_CFG} ]]; then
			netcatd_id=$(get_netcard_id)
		fi
		devcon disable *${netcatd_id}*
		sleep 2
		devcon enable *${netcatd_id}*
		# 下面的方法在xp下不起作用
		#netsh interface set interface name="$(get_netcard_name)" admin=disabled
		#sleep 2
		#netsh interface set interface name="$(get_netcard_name)" admin=enabled
	fi
	echo "Restart network card $(get_netcard_name) successfully!"
}

# 设置ip地址..
# 接收一个参数,$1:ip地址
# 顺便提醒一下默认子网掩码这里设置为255.255.255.0
function set_ip_addr()
{
	echo "Setting ip address $1 ..."
	if [[ $(get_os_type) == "Unix" ]]; then
		# 配置中不存在该网卡的配置..
		if [[ "$(cat ${IFUPDOWN_CFG} | grep "^ *auto .*$(get_netcard_name)" )" == "" ]]; then
			sudo echo -e "auto $(get_netcard_name)\niface $(get_netcard_name) inet static" >> ${IFUPDOWN_CFG}
			sudo echo -e "address $1" >> ${IFUPDOWN_CFG}
			sudo echo -e "netmask 255.255.255.0" >> ${IFUPDOWN_CFG}
		else
			# 配置中出现该网卡的配置，那么我们将强制改为静态ip地址..
			# 插入iface语句并设置了静态
			sudo sed -ie "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/^ *iface.*/iface $(get_netcard_name) inet static/}" ${IFUPDOWN_CFG}
			# 判断是否存在address关键字，不存在的话在在第二个auto的前一行插入address及其ip地址..和默认netmask
			if [[ "$(sed -n "/^ *auto .*$(get_netcard_name)/,/^ *auto/{/^ *address.*/p}" ${IFUPDOWN_CFG})" == "" ]]; then
				sed -e "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/\(^ *iface.*\)/\1\naddress $1\nnetmask 255.255.255.0/g}" ${IFUPDOWN_CFG}
			else
				# 如果已经存在了那么匹配address语句并整行替换...
				sudo sed -ie "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/^ *address.*/address $1\nnetmask 255.255.255.0/}" ${IFUPDOWN_CFG}
			fi
		fi
	else
		netsh interface ip set address name="$(get_netcard_name)" static $1 255.255.255.0
	fi
}

# 设置dns...
# 接受一个参数$1,表示要设置的dns字符串，多个dns之间用空格隔开
function set_dns()
{
	echo "Setting dns $1 ..."
	local dns_str=$1
	if [[ "$(get_os_type)" == "Unix" ]]; then
		# 先判断是否添加了重复的..
		if [[ "$(cat /etc/resolvconf/resolv.conf.d/base | awk '$2==${dns_str}')" == "" ]]; then
			# 下面这个文件只有在你的系统安装了resolvconf之后才会出现..
			sudo echo "nameserver "$1 >> /etc/resolvconf/resolv.conf.d/base
		fi
	else
		netsh interface ip set dns name="$(get_netcard_name)" source=static addr=$1 register=PRIMARY
	fi
}

# 设置网关..
# 接收一个参数,$1:网关地址..
function set_gw()
{
	echo "Setting gateway address $1 ..."
	if [[ $(get_os_type) == "Unix" ]]; then
		if [[ "$(cat ${IFUPDOWN_CFG} | grep "^ *auto .*$(get_netcard_name)" )" == "" ]]; then
			sudo echo -e "auto $(get_netcard_name)\niface $(get_netcard_name) inet static" >> ${IFUPDOWN_CFG}
			sudo echo -e "gateway $1" >> ${IFUPDOWN_CFG}
		else
			# 配置中出现该网卡的配置，那么我们将强制改为静态ip地址..
			# 插入iface语句并设置了静态
			sudo sed -ie "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/^ *iface.*/iface $(get_netcard_name) inet static/}" ${IFUPDOWN_CFG}
			# 判断是否存在address关键字，不存在的话在在第二个auto的前一行插入address及其ip地址..和默认netmask
			if [[ "$(sed -n "/^ *auto .*$(get_netcard_name)/,/^ *auto/{/^ *gateway.*/p}" ${IFUPDOWN_CFG})" == "" ]]; then
				sed -e "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/\(^ *iface.*\)/\1\ngateway $1/g}" ${IFUPDOWN_CFG}
			else
				sudo sed -ie "/^ *auto .*$(get_netcard_name)/,/^ *auto/{s/^ *gateway.*/gateway $1/}" ${IFUPDOWN_CFG}
			fi
		fi
	else
		netsh interface ip set address "$(get_netcard_name)" gateway=$1 gw=1
	fi
}

# Unix only
# 由ifupdown命令及其配置文件接管网络管理(取代networkmanger)
function enable_ifupdown()
{
	if [[ "$(cat /etc/NetworkManager/*.conf | grep "managed" | cut -d '=' -f2)" == "false" ]]; then
		echo Enable ifupdown successfully
	else
		# 之所以用通配符匹配Networkmanager下的conf文件，是因为不同版本的Networkmanager的配置文件名不一样
		sudo sed -ie 's/managed.*/managed=false/' /etc/NetworkManager/*.conf
		echo Enable ifupdown successfully
	fi
}

# 将当前网络链接的参数以一定格式保存在文件中或者从一定格式的文件恢复
# 接受两个参数,$1固定为dump或者restore,$2备份信息保存的文件或者恢复的文件..
function net_time_machine()
{
	if [[ $1 == "dump" ]]; then
		echo "Dumpping network config..."
		if [[ $(get_os_type) == "Unix" ]]; then
			sudo mkdir -p ${2%/*}
			if [[ "$(cat ${IFUPDOWN_CFG} | grep "auto *$(get_netcard_name)" )" == "" ]]; then
				# 在interfaces文件中没有当前网卡的配置，所以需要获取相关信息然后写入，然后在保存..
				is_dhcp
				if [[ $? -eq 0 ]]; then
					sudo echo -e "auto $(get_netcard_name)\niface $(get_netcard_name) inet dhcp" >> ${IFUPDOWN_CFG}
				else
					sudo echo -e "auto $(get_netcard_name)\niface $(get_netcard_name) inet static" >> ${IFUPDOWN_CFG}
					sudo echo -e "address $(get_ip_addr)\nnetmask $(get_netmask)\ngateway $(get_gw)\nhwaddress ether $(get_mac_address)" >> ${IFUPDOWN_CFG}
				fi
			fi
			sudo cp ${IFUPDOWN_CFG} $2
		else
			mkdir -p ${2%/*}
			netsh -c interface dump > $2
			echo "# macaddress;$(get_mac_address)" >> $2
			echo "# netcatd_id;$(get_netcard_id)" >> $2
			echo "# reg_pos_of_mac;$(get_pos_of_mac_in_reg)" >> $2
		fi
	elif [[ $1 == "restore" ]]; then
		echo -e "\nRestore network config..."
			if [[ $(get_os_type) == "Unix" ]]; then
				read -n1 -p  "Are you sure to overwrite ${IFUPDOWN_CFG}[y/n]" user_input
				echo -e "\n"
				if [[ "${user_input}" == "" || "${user_input}" == [yY] ]]; then
					sudo cp $2 ${IFUPDOWN_CFG}
				fi
			else
				netsh -f $2
				set_mac_addr $(cat $2 | grep macaddress | cut -d ';' -f2)
			fi
		echo  "Restore Successfully!"
	else
		echo  "wrong arg.."
		echo "$0 dump|restore filename"
	fi
}

# 类似于编译程序时configure程序的作用：检查依赖
# 接受一个字符串参数，每个命令之间用空格隔开...
function configure()
{
	local package_lack=""
	for i in $1
	do
		which $i > ${TEMP_FILE} 2>&1
		if [[ $? -ne 0 ]]; then
			echo -e "Checking $i ..... no"
			package_lack="$i ${package_lack}"
		else
			echo -e "Checking $i ..... yes"
		fi
	done	
	if [[ ${package_lack} != "" ]]; then
		echo "Please install ${package_lack} manually!"
		rm -f ${TEMP_FILE}
		exit 3
	fi
	rm -f ${TEMP_FILE}
}
# }}}

# {{{脚本进程

#  环境检查..
if [[ "$(get_os_type)" == "Unix" ]]; then
	configure "ifup ifdown resolvconf cat grep sed awk"
	enable_ifupdown
else
	configure "netsh devcon cat grep sed awk getmac reg"
fi

# 备份当前用户的网络配置
if [[ ! -s "${ORIG_IFUPDOWN_CFG}" ]]; then # not exist or it's size is zero
	net_time_machine "dump" ${ORIG_IFUPDOWN_CFG}
fi

# 大循环...
while [[ 1 ]]; do
	declare -i nump=1 #计数.. 
	# 开始读取配置文件
	echo "Reading network config..."
	if [[ -s "${USER_NETOWRK_CFG}" ]]; then
		CFG_NAME=$(read_a_name_of_conf ${USER_NETOWRK_CFG} 1)
		#没有找到任何配置
		if [[ "${CFG_NAME}" == "" ]]; then
			read -n1 -p  "There are no config in ${USER_NETOWRK_CFG},would you like to add one?[y/n]" user_input
			echo -e "\n"
			if [[ "${user_input}" == "" || "${user_input}" == [yY] ]]; then
				add_cfg
				continue #返回重新读取配置文件.. 
			else
				break
			fi
		fi

		clear_screen
		#打印找到的所有配置的名字
		# 输出友好的提示信息让用户选择
		echo  "This is network_quick_switch tool."
		echo  "0,restore default config."
		while [[ "${CFG_NAME}" != "" ]]; do
			echo  "${nump},${CFG_NAME}"
			nump=${nump}+1
			CFG_NAME=$(read_a_name_of_conf ${USER_NETOWRK_CFG} ${nump})
		done
		echo  "q,quit the script."
		echo  "a,add a config."
		echo  "s,Setting current network config as default"
		echo  "----------------------------"

		nump=${nump}-1
		read -n1 -p  "Please input the character at the begin of each line:" user_input
		echo -e "\n"
		until [[ "${user_input}" == [0-${nump}qas] ]]; do
			read -n1 -p  "Error!Try again!Only 0 to ${nump} or q,a,s are allowed:" user_input
			echo -e "\n"
		done

		#开始配置
		if [[ "${user_input}" == 0 ]]; then
			echo "Import original config..."
			if [[ ! -e "${ORIG_IFUPDOWN_CFG}" ]]; then
				echo "Import failed...no original config file!"
				continue
			fi
			net_time_machine "restore" ${ORIG_IFUPDOWN_CFG}
		elif [[ "${user_input}" == q ]]; then
			break
		elif [[ "${user_input}" == a ]]; then
			add_cfg
			continue
		elif [[ "${user_input}" == s ]]; then
			net_time_machine "dump" ${ORIG_IFUPDOWN_CFG}
			break
		else
			CFG_NAME=$(read_a_name_of_conf ${USER_NETOWRK_CFG} ${user_input})
			CFG_IP=$(read_a_field_of_conf ${USER_NETOWRK_CFG} ${user_input} ${CFG_IP_IDX})
			CFG_MAC=$(read_a_field_of_conf ${USER_NETOWRK_CFG} ${user_input} ${CFG_MAC_IDX})
			CFG_DNS=$(read_a_field_of_conf ${USER_NETOWRK_CFG} ${user_input} ${CFG_DNS_IDX})
			set_mac_addr $CFG_MAC
			set_ip_addr ${CFG_IP}
			set_dns ${CFG_DNS}
			#重启网卡..
		fi
		reset_netcard
		break
	else #找不到配置配置文件询问是否需要建立 
		read -n1 -p  "There are no config in ${USER_NETOWRK_CFG},would you like to add one?[y]" user_input
		echo -e "\n"
		if [[ "${user_input}" == "" || "${user_input}" == [yY] ]]; then
			add_cfg
			continue #返回重新读取配置文件.. 
		else
			break
		fi
	fi
done

rm -f ${TEMP_FILE}
# 结束语==!
echo -e "\nThank you for using network_quick_switch"
echo -e "Contact me by email:tracyone@live.cn"

# }}}

# vim: set ft=sh fdm=marker foldlevel=0 foldmarker&: 
